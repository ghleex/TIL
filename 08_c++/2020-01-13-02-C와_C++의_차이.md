### 2020-01-13

# :heavy_plus_sign: C++

# 4**. C 언어와 C++ 언어의 차이(2)**

## **학습 내용**

- 동적 할당 메모리란?
- 이름 공간이란?

## **학습 목표**

- 동적 할당 메모리에 대한 개념을 확고히 한다.
- 메모리를 동적으로 할당할 수 있다.
- 이름 공간이 무엇인지 설명할 수 있다.

## **사전 퀴즈**

- 동적으로 할당된 메모리는 사용이 끝나면 자동으로 시스템에 반환된다. → 정답: X
  - 자동으로 반환되지 않으며, 프로그래머는 동적으로 할당된 메모리의 사용이 끝나면 시스템에 메모리를 반납하는 코드를 따로 작성해야 함

## **1. 동적 할당 메모리란?**

### **1.1. 동적 할당 메모리의 개념**

- 프로그램이 메모리를 할당 받는 방법

  - 정적(Static)
  - 동적(Dynamic)

- 정적 메모리 할당

  - 프로그램이 시작되기 전에 미리 정해진 크기의 메모리를 할당받는 것

  - 메모리의 크기는 프로그램이 시작하기 전에 결정

    ```c++
      int i, j;
      int buffer[80];
      char name[] = "data structure";
    ```

  - 처음에 결정된 크기보다 더 큰 입력이 들어온다면 처리하지 못함

  - 더 작은 입력들이 들어온다면 남은 메모리 공간은 낭비

### 1.2. 동적 메모리

- 실행 도중에 동적으로 메모리를 할당받는 것

- 사용이 끝나면 시스템에 메모리를 반납

- 필요한 만큼만 할당을 받고 메모리를 매우 효율적으로 사용

- `new` 와 `delete` 키워드 사용

  \#include <iostream> using namespace std;

  int main() { int *p; p = new int; ... }

### 1.3. 동적 메모리 할당 과정

```c++
#include <iostream>
using namespace std;

int main() {
    int *pi;        // 동적 메모리를 가리키는 포인터
  
    pi = new int;   // 1. 동적 메모리 할당
    *pi = 100;      // 2. 동적 메모리 사용
    delete pi;      // 3. 동적 메모리 반납

    return 0;
}
```

### 1.4. 파생 자료형인 경우

- 배열

  ```c++
  double *pd = new double[10];
  ...
  delete[] pd;
  ```

### 1.5. 메모리 누수 예제

```c++
void sub() {
    int *pi = new int;   // (1)
    *pi = 67;
    delete pi;           // 이 부분을 넣어야 올바름

    pi = new int;        // (2)
    *pi = 99;
    delete pi;           // 이 부분을 넣어야 올바름
}
```

### 1.6. `const` 포인터

- `constint *p1;`
  - `p1` 은 `constint` 에 대한 포인터
  - `p1` 이 가리키는 내용이 상수가 됨
  - `*p1 = 100;` (X)
- `int *const p2;`
  - 정수를 가리키는 `p2` 가 상수라는 뜻
  - `p2` 의 내용이 변경될 수 없음
  - `p2 = p1;` (X)

## 2. 이름 공간이란?

### 2.1. 이름 공간(Namespace)

- 식별자들이 존재하는 공간
- 이름 공간은 식별자들이 충돌하는 문제를 해결하기 위하여 제안됨
- 식별자 공간을 논리적으로 분할하고 식별자의 범위를 제한하는 것이 가능

### 2.2. 이름 공간 정의

- 형식

  ```c++
    namespace 이름 {
        변수 정의;
        함수 정의;
        클래스 정의;
        ...
    }
  ```

- 예

  ```c++
    namespace Graphics {
        int mode;
        int x, y;
        void draw();
        void message();
        ...
    }
  ```

### 2.3. 같은 이름 사용 가능

```c++
namespace Graphics {
    int mode;
    int x, y;
    void draw();
    void message();
    ...
}

namespace Network {
    int mode;
    int speed;
    void send(char *);
    void message();
    ...
}
```

### 2.4. 이름 공간 지정

- 이름 공간 `Graphics` 안의 변수 `mode` 를 사용하려면?

  ```c++
    Graphics::mode = 1;
    Network::mode = 1;
    // 위와 같이 이름 공간을 지정
  ```

### 2.5. 예제

```c++
#include <iostream>
using namespace std;
int mode; // 전역변수 mode

namespace Graphics {
    int mode;
    int x, y;
    void draw() { cout << "Graphics 맑은 고딕 draw()" << endl; };
    void message() { cout << "Graphics 이름 공간 안의 message()" << endl; };
}

namespace Network {
    int mode, speed;
    void send(char *) { cout << "Graphics 이름 공간 안의 send()" << endl; };
    void message() { cout << "Network 이름 공간 안의 message()" << endl; }
}

int main() {
    // x = y = 100;        // 컴파일 오류!
    // speed = 22900;      // 컴파일 오류!
    // draw();             // 컴파일 오류!

    mode = 1;              // 전역변수
    Graphics::mode = 1;
    Network::mode = 2;

    Graphics::message();
    Network::message();
    return 0;
}
```

### 2.6. `using` 문

- `using 이름공간::식별자;`
  - 다음과 같이 선언하면 `Network` 안의 `mode` 는 이름 공간을 붙이지 않아도 접근 가능
  - `using Network::speed;`
  - `speed = 100;` :  `Network` 이름 공간 안의 `speed` 를 의미
- `using namespace 이름공간;`
  - `using namespace Network;`
  - `speed = 19200;` :  `Network` 이름 공간 안의 `speed` 를 의미
  - `send("This is a test");` :  `Network` 이름 공간 안의 `send()` 를 의미

### 2.7. 전역 범위 접근

- 연산자 사용
  - 예) `::mode=0;`

### 2.8. 예제

```c++
#include <iostream>
using namespace std;

int mode;    // 전역변수 mode
void message() {
    cout << "전역 공간 안의 message()" << endl;
}

namespace Graphics {
    int mode;
    int x, y;
    void draw() { cout << "Graphics 이름 공간 안의 draw()" << endl; };
    void message() { cout << "Graphics 이름 공간 안의 message()" << endl; };
}

int main() {
    using namespace Graphics;

    // mode = 1;            // 컴파일 오류!
    Graphics::mode = 1;     // Graphics 공간 안의 mode
    ::mode = 1;             // 전역변수 mode

    // message();           // 컴파일 오류!
    Graphics::message();    // Graphics 공간 안의 message()
    ::message();            // 전역 함수

    return 0;
}
```

### 2.9. 이름 공간과 소스 파일

```c++
// src1.cpp
namespace A {
    .....
}

namespace A {
    ....
}
// 하나의 소스 파일에 여러 개의 이름 공간을 정의할 수 있음


// src2.cpp
namespace A {
    .....
}
namespace A {
    ...
}
// 같은 이름 공간이 여러 소스 파일에 걸쳐 정의 가능
```

### 2.10. 이름 공간과 헤더 파일

```c++
// graphics.h
namespace Graphics {
    extern int x;
    extern int y;
    void draw();
    ...
}


// graphics.cpp
#include "graphics.h"

int Graphics::x = 0;
void Graphics::draw() {
    ...
}
...


// graphics.cpp
#include "graphics.h"

int Graphics::x = 0;
void Graphics::draw() {
    ...
}
...
```