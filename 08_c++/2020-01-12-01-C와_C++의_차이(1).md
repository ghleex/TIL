### 2020-01-12

# :heavy_plus_sign: C++

## 3. C 언어와 C++ 언어의 차이(1)

### 학습 내용

* 변수, 자료형 및 함수의 변경
* 레퍼런스 활용



### 학습 목표

* 변수와 자료형에서 일반 C 언어와의 차이점을 설명할 수 있다
* 레퍼런스와 포인터에 대하여 개념을 확고히 정립한다.



### 사전 퀴즈

* 포인터(*)와 레퍼런스(&)는 똑같다? → 정답: X
  * 레퍼런스는 변수에 별명을 붙이는 것
  * 참조하는 대상이 수시로 변경되는 경우, 포인터 사용





### 1. 변수, 자료형 및 함수의 변경

#### 1.1. 변수 선언 위치 변경

```c++
int getSum(int array[], int n) {
    cout << "변수는 어디서나 선언이 가능합니다" << endl;
    int sum = 0;
    for (int i=0; i<n; i++)
        sum += array[i];
    return 0;
}
```

#### 1.2. 엄격한 자료형 검사

```c++
int sub(int n) {
    // ...
    return 0;
}
```

#### 1.3. `bool` 형

* 참과 거짓을 나타내기 위한 `bool` 형 도입

```c++
bool isLarger = false;
if (x > y)
    isLarger = true;
else
    isLarger = false;
```

#### 1.4. 구조체

* 구조체는 변수들을 모아놓은 것
* 태그만으로도 구조체 변수 정의 가능

```c++
struct _point {
    int x;
    int y;
}
struct _pointp1; // C 방식
_pointp2;		 // C++ 방식
```

#### 1.5. 레퍼런스

* 레퍼런스(reference): 변수에 별명을 붙이는 것

  `int &ref = var;`

* 레퍼런스 `ref` 는 변수 `var` 의 별명(alias)이다.

#### 1.6. 예제

```c++
#include <iostream>
using namespace std;

int main() {
    int var;
    int &ref = var;			// 레퍼런스 선언
    
    var = 10;
    cout << "var의 값:" << var << endl;
    cout << "ref의 값:" << ref << endl;
    
    ref = 20;				// ref 값을 변경하면 var 값도 변경
    cout << "var의 값:" << var << endl;
    cout << "ref의 값:" << ref << endl;
    
    return 0;
}
```

#### 1.7. 주의할 점

```c++
int n = 10, m = 20;
int &ref = n;

ref = m;		// 컴파일 오류! - 변경 불가
int &ref;		// 컴파일 오류! - 초기화되지 않음
int &ref = 10	// 컴파일 오류! - 상수로 초기화 불가
```

#### 1.8. 참조에 의한 호출(레퍼런스)

```c++
#include <iostream>
using namespace std;
void swap(int &rx, int &ry);

int main() {
    int a = 100, b = 200;
    cout << "swap() 호출 전: a =" << a << ", b =" << b << endl;
    swap(a, b);
    cout << "swap() 호출 후: a =" << a << ", b =" << b << endl;
    return 0;
}

void swap(int &rx, int &ry) {
    int tmp;
    
    cout << "In swap(): rx =" << rx << ", ry =" << ry << endl;
    tmp = rx; rx = ry; ry = tmp;
    cout << "In swap(): rx =" << rx << ", ry =" << ry << endl;
}
```

![2020-01-12-01](https://user-images.githubusercontent.com/52685206/72214203-b6d7da80-3540-11ea-835c-cdbf2d6833d2.PNG)



### 2. 레퍼런스 활용

#### 2.1. 레퍼런스를 이용한 변환

```c++
#include <iostream>
using namespace std;

enum RCODE { SUCCESS, ERROR };

// 기울기와 y 절편 계산
RCODE get_line_parameter(int x1, int y1, int x2, int y2, float &slope, float &yintercept) {
    if ( x1 == x2 ) {
        return ERROR;
    }
    else {
        slope = (float)(y2 - y1) / (float)(x2 - x1);
        yintercept = y1 - slope * x1;
        return SUCCESS;
    }
}

int main(){
    float s, y;
    
    if ( get_line_parameter(3, 3, 6, 6, s, y) == ERROR ) {
        cout << "에러" << endl;
    }
    else {
        cout << "기울기는" << s << endl << "y절편은" << y << endl;
    }
    
    return 0;
}
```

#### 2.2. 레퍼런스를 통한 효율성 향상

* 객체의 크기가 큰 경우, 복사는 시간이 많이 걸림
  * 이때, 레퍼런스로 처리하는 것이 유리

#### 2.3. 레퍼런스를 통한 변경을 방지하려면

* `const` 를 앞에 붙이면 레퍼런스가 가리키는 내용이 변경 불가능한 상수라는 뜻

  ```c++
  void sub(const int &p) {
      p = 0;		// 오류 발생!
  }
  ```

#### 2.4. 포인터 vs. 레퍼런스

* 일반적으로 레퍼런스를 사용하는 편이 쉬움
* 만약 참조 대상이 수시로 변경되는 경우, 포인터 사용
* `NULL` 이 될 가능성이 있는 경우에도 포인터 사용

```c++
int *p = new int;
if ( p != NULL ){
    int &ref = *p;
    ref = 100;
}
```

#### 2.5. 디폴트 매개 변수(Default Parameter)

* 인자를 전달하지 않아도 디폴트 값을 대신 넣어주는 기능

```c++
void sub(double value = 1.0);
int main() {
    sub();
    return 0;
}

void sub(double value) {
    return 2 * value;
}
```

#### 2.6. 주의할 점

* 디폴트 매개 변수는 뒤에서부터 앞쪽으로만 정의할 수 있음

```c++
void sub(int p1, int p2, int p3 = 30);				// OK
void sub(int p1, int p2 = 20, int p3 = 30);			// OK
void sub(int p1 = 10, int p2 = 20, int p3 = 30);	// OK

void sub(int p1, int p2 = 20, int p3);		// 컴파일 오류!
void sub(int p1 = 10, int p2, int p3 = 30);	// 컴파일 오류!
```

#### 2.7. 예제

```c++
#include <iostream>
using namespace std;

int calc_deposit(int salary = 300, int month = 12);

int main() {
    cout << "0개의 디폴트 매개 변수 사용" << endl;
    cout << calc_deposit(200, 6) << endl;
    
    cout << "1개의 디폴트 매개 변수 사용" << endl;
    cout << calc_deposit(200) << endl;
    
    cout << "2개의 디폴트 매개 변수 사용" << endl;
    cout << calc_deposit() << endl;
    return 0;
}

int calc_deposit(int salary, int month) {
    return salary * month;
}
```

![2020-01-12-02](https://user-images.githubusercontent.com/52685206/72214443-5f883900-3545-11ea-9daa-6b31d6d5aa1e.PNG)

#### 2.8. 중복 함수(Overloading Functions)

* 같은 이름을 가지는 함수를 여러 개 정의하는 것

```c++
// 정수 값을 제곱하는 함수
int square(int i) {
    return i * i;
}

// 실수 값을 제곱하는 함수
double square(double i) {
    return i * i;
}
```

#### 2.9. 예제

* C++ 에서는 들어가는 인자가 정수인지 실수인지에 따라 컴파일러가 자동으로 binding 해 줌

```c++
int main() {
    cout << square(10) << endl;
    cout << square(2.0) << endl;
    
    return 0;
}
```

#### 2.10. 중복 함수의 장점

* 중복 함수를 사용하지 않은 경우

  ```c++
  square_int(int int);
  square_double(double int);
  square_short(short int);
  ```

* 중복 함수를 사용하는 경우

  ```c++
  square(int int);
  sqaure(double int);
  square(short int);
  ```

#### 2.11. 주의할 점

```c++
int sub(int);

int sub(int, int);		// 중복 가능
int sub(int, double);	// 중복 가능
double sub(double);		// 중복 가능

double sub(int);		// 오류 - 반환형이 다르더라도 중복 불가
float sub(int, int);	// 오류 - 반환형이 다르더라도 중복 불가
```

* 인라인 함수(inline function)

  * 함수 호출을 하지 않고 코드를 복사해 넣는 것
  * inline 인 경우, 함수 몸체를 호출한 곳에 삽입

  ```c++
  int main() {
      int result = square(10);
      // int result = 10 * 10
      return 0;
  }
  
  // 정수값을 제곱하는 함수
  inline int square(int i){
      return i * i;
  }
  ```

#### 2.12. 인라인 함수 예제

```c++
int main() {
    double result;
    
    cout << "2.0의 제곱은";
    result = square(2.0);
    cout << result << endl;
    
    cout << "3.0의 제곱은";
    result = square(3.0);
    cout << result << endl;
    
    return 0;
}
```

